---
layout: post
title: Web 2.0 기반 블록체인 커뮤니티 프로젝트
subtitle: Second project
categories: Blockchain
tags: [Blockchain, Project, Web3.0]
---

Second project - Web 2.0 기반 블록체인 인센티브 커뮤니티
------------

프로젝트 1이 끝이나고 드디어 두번째 프로젝트가 시작되었다. 기간은 대략 2주정도 주어졌고 나를 포함한 네명의 팀으로 프로젝트를 진행하게 되었다.

프로젝트 1과 다르게 이번에는 백엔드 서버의 개발도 필요하게 되었는데 개발 해야하는것이 하나만 늘어난 것인데 개인적으로 프로젝트의 난이도가 많이 올랐다고 느꼈다.

이번에도 내가 팀장을 맡아 프로젝트를 매니징 하였으며 프로젝트를 시작하면서 역할 분담과 함께 Agile하게 프로젝트를 진행하기 위해

Agile 방법론을 팀원들에게 설명하고 최대한 그에 맞춰서 진행하였다.

이번에는 기간이 늘기는 했지만 그래도 2주라는 기간은 짧았기에 Sprint를 총 세개로 나눠 진행했으면 첫번째 Sprint는 구체적은 우리의 프로덕트 구상과 계획을 하기로 했고

두번째 Sprint는 본견적인 개발단계 그리고 세번째 Sprint에서 리팩토링과 디버깅을 진행하기로 했다.

자세한 이야기는 아래에서 더 세부적으로 진행해보겠다.

### Team ###

위에서 언급한대로 나 포함 총 네명의 팀원이 한 팀이 되었고 본인이 팀장을 맡으면서 프로젝트 매니징을 하면서 프로젝트를 시작해보기로 했다.

- 팀장: 팀장인 나는 프로젝트 매니지먼트를 하면서 프로젝트의 올바른 방향성을 제시하면서 시간내에 프로젝트를 완료할 수 있는것에 목표를 두었다. 그리고 개발적인 부분은 우리 프로젝트의 백엔드 서버 및 Daemon의 구현을 맡았다.

- 팀원1: 팀원 한 분은 나와 같이 백엔드 서버를 맡기로 했다. 같이 긴밀하게 소통을 하며 구현해야 기능을 세부적으로 나눠 각자 구현을 하였다.

- 팀원2: 또 다른 팀원 한분은 React를 활용하여 클라이언트 개발을 맡기로 했다. 백엔드 팀에서 제공해주는 API 문서를 토대로 기능을 구현하였고 뿐만아니라 CSS 스타일링까지 진행하였다.

- 팀원3: 마지막 팀원분은 우리의 프로덕트가 사용할 스마트 컨트랙트를 맡아주셨다.

### Project Management ###

이번 프로젝트도 위에서 말한대로 내가 팀장을 맡게 되어 프로젝트 매니징을 담당했다. 프로젝트 1과 동일하게 Agile 방법론과 SCRUM 프레임워크를 사용하여 프로젝트를 진행했다.

프로젝트를 대부분 처음 하시는 분들이여서 Agile 방법론과 SCRUM 프레임워크에 대해 간단하게 설명해드렸는데 지금 생각해보면 내 설명이 조금 부족했다는 생각이 들었다.

왜냐하면 Agile 방법론이라는 것은 우선순위가 높은 task를 여러 iterations을 거치면서 지속적으로 테스트를 하면서 진행하는 것인데

나중에 얘기하겠지만 프로젝트 자체는 무난히 완주했지만 그 우선순위 높은 task를 먼저한다는 부분이 잘 지켜지지 않았던것 같았다.

다행히 우리가 목표로 하는 프로덕트를 개발하기는 했지만 이 부분에 있어서는 팀장이였던 나의 역할을 제대로 수행하지 못한것같아

아쉬웠다. 하지만 이렇게 프로젝트를 하면서 아쉬웠던 부분을 회고하며 배워나가는 부분이라고 생각이 들어서 다음에는 좀더 잘 할 수 있다는 생각이든다.

그럼 아래에서 각 Sprint에서 있었던일을 회고하며 기술적으로 이슈가 있었던 부분을 얘기해보겠다.

### Sprint 01 ###

Sprint 01에서는 얘기한대로 각자의 역할분담과 프로젝트 구상 그리고 Software Requirements에 대한 계획을 짰다.

우선순위에 관한 내용이 잘 전해진것 같지 않아서 본격적인 개발에 착수 했을때 우선순위를 생각하지 않고 개발이 진행되었다.

물론 잘 마무리 하기는 했지만 아쉬운 부분이 있었던것은 사실이여서 다음에는 이 부분을 간과하지말고 또 팀장을 맡게 된다면 팀원 분들에게 잘 설명을 할 수 있도록 해야겠다고 느꼈다.

그리고 프로젝트 1에서 느낀 부분이 있어서 역할분담을 하기전에 팀원분들에게 나중에 취업하게 되면 하고 싶은 직무에 관해 물어보고

역할분담을 하였다. 왜냐하면 이 프로젝트는 우리가 프로젝트를 배우기 위한 하나의 스탭으로도 볼 수 있지만 우리가 성공적으로 프로젝트를 완주한다면 

이 프로젝트를 포트폴리오로 사용 할 수 있기때문에 역할을 최대한 자신이 원하는 직무와 관련되게 하면 좋겠다고 생각했기 때문이다.

나는 미래에 블록체인을 활용한 풀스택 개발자를 꿈꾸기 때문에 프로젝트 1에서 프론트엔드를 진행하여 이번 프로젝트 2에서는 팀장역할과 백엔드 개발을 맡기로 했다.

나머지 분들도 그에 맞춰 백엔드, 프론트엔드, 스마트 컨트랙트 개발을 맡았다.

밑의 Sprint 02에서 본격적인 개발에 대해서 얘기해보겠다.

### Sprint 02 ###

Sprint 02에서 본격적인 개발 단계가 진행이 되었고 Sprint 01에서 계획해놓은 task들을 가져가면서 각자 개발에 착수 하였다.

프로젝트 1과 다르게 프로젝트 2에서는 백엔드의 개발이 필요하다고 말했었다. 프로젝트 2에서도 프로젝트 1과 같이 **개발이 동기적으로 진행** 되는 문제가 생겼는데

클라이언트에서 백엔드가 개발하는 API를 토대로 기능을 개발하여야하기 때문에 백엔드 팀에서 API 구현을 완료하지 않으면 클라이언트에서의 개발이 쉽지 않은 점이었다.

프로젝트 01 리뷰 세션에서 크루분에게 프로젝트 개발을 비동기적으로 진행하는 방법에 대해 조언을 구하였고 거기서 들은 답변을 토대로

팀원들끼리 잘 이야기를 하며 개발 진행을 어떻게 할건지 정하였다.

일단 클라이언트는 백엔드가 API 개발을 완료하기전에 더미 데이터를 이용해서 마치 API 호출을 하는것처럼 구현을 하여 테스트를 하면서 진행해보기로 했다.

그러면서 API 개발이 완료되면 실제로 API 호출을 진행하며 테스트를 하여 수정해야되는 부분이 있으면 우리 백엔드팀에 알려주기로 했다.

결론 부터 말하자면 다행히 얘기 한대로 잘 진행이 되었다.

이런 문제는 우리 백엔드팀에서도 동일하게 발생했는데 프로젝트 이름과 같이 Web 2.0 기반이지만 블록체인을 활용한 커뮤니티의 개발 이여서

백엔드 서버가 블록체인상의 계정을 하나가지고 있고 그 계정이 모든 Transaction을 관리하여야했다. (이 계정을 이제 서버계정이라고 하겠다.)

서버계정이 트랜잭션을 잘 핸들링하는지 테스트하기 위해서는 스마트 컨트랙트 개발이 완료되고 배포를 해서 확인을 할 수 있었는데 이 부분은

OpenZeppelin으로 가장 기본적인 ERC-20과 ERC-721 스마트 컨트랙트를 만들어 배포한 다음 해당 스마트 컨트랙트를 활용해서 로컬 가나슈 RPC 서버에서 제대로 동작하는지 확인하면서 진행했다.

그래서 팀 전체가 자신이 맡은 부분을 비동기적으로 개발을 진행할수있게 되었다.

이때까지는 프로젝트 그 자체와 관련해서 어떤 이슈가 있었고 어떻게 해결했는지를 얘기해보았고 이제 밑에서는 개발하면서 생긴 기술적인 이슈에 관해서 얘기해보겠다.

#### Error 01 ####

위에서 말한대로 우리의 어플리케이션은 서버 계정이 모든 트랜잭션을 보내면서 유저들의 계정을 대신해서 그들의 자산을 관리한다.

그러니까 프로젝트 1과 같이 유저 계정이 직접 트랜잭션을 보내는게 아니라 서버 계정이 트랜잭션을 대신해서 보내준다는 말이다.

그렇게 하기 위해서는 유저의 계정이 가진 모든 balance를 서버 계정에게 approve 해주는 식으로 하면 된다.

문제는 서버 계정이 여러 트랜잭션을 보낼때 이미 보낸 트랜잭션이 pending에 걸려있고 또 다른 트랜잭션의 요청이 들어왔을때 nonce 값이 동일해지는 문제가 발생하여

트랜잭션 하나가 pending에 걸려있으면 더 이상 트랜잭션이 보내지지 않는 에러가 발생했다.

nonce 값이 같은 트랜잭션을 또 보내는것이 잘못된 것은 아니다. 해당 nonce 값을 가진 transaction을 status가 sucess하기 전에 수정할때는 이렇게 같은 nonce 값을 가진 트랜잭션을 보냄으로서 수정을 하는데

수정하기위해서는 gasPrice가 기존의 gasPrice보다 10%가 높아진 값으로 보내야지 수정이된다.

어쨌든 우리는 수정이 필요한게 아니라 새로운 트랜잭션을 보내려고 하기 때문에 nonce 값을 트랜잭션을 보낼때마다 늘려주면되기 때문에

`web3.eth.getTransactionCount(서버 계정 주소)` 함수를 사용하여 nonce값을 업데이트 해주는 식으로 하였다.

하지만 이 함수를 사용해도 nonce 값이 같아지는 문제가 발생했고 공식문서를 확인한 결과 getTransactionCount 함수의 두번째 인자로 string을 넣어주면 이 문제를 해결할 수 있다는 것을 확인했다. [공식문서](https://web3js.readthedocs.io/en/v1.7.3/web3-eth.html#gettransactioncount)는 여기서 확인하자!

두번째인자의 string은 `"eariliest", "latest", "pending"`을 넣을 수 있고 두번째 인자는 optional이기 때문에 넣지않으면 자동으로 `web3.eth.defaultBlock()`를 호출해서 두번째 인자로 넣고 함수를 실행한다.

우리가 원하는 것은 pending에 걸려있는 트랜잭션까지 확인해서 nonce 값을 업데이트 하는 것이기 때문에 두번째 인자로 `"pending"`을 넣어주면 된다.

이렇게 함수를 사용하니 nonce 값이 pending이 걸려있는 트랜잭션까지 카운팅해서 업데이트 되었다.

#### Error 02 ####

두번째로 발생한 문제는 gasLimit과 관련해서 생긴 문제였다.

트랜잭션을 보낼때 gasLimit을 설정해주어야하는데 보통 사용하고 남은 gas는 다시 돌려주기 때문에 gasLimit을 2000000정도로 설정해서 트랜잭션을 보냈다.

공식문서를 살펴보니 `methods.myMethod().estimateGas()`라는 함수가 있었고 이 함수를 이용해서 미리 예상되는 가스 사용량을 계산을 해서 gasLimit을 설정해주기로 했다.

하지만 이 함수를 사용하니까 gasLimit을 하드코딩으로 이백만을 주었을때는 발생하지 않은 `out of gas` 에러가 계속 발생했다.

이것도 [공식문서](https://web3js.readthedocs.io/en/v1.7.3/web3-eth-contract.html?highlight=estimate#methods-mymethod-estimategas)를 자세히 살펴보고 해결방법을 찾았다.

```nodejs
const gasLimit = await web3.eth.estimateGas({
  data: bytecodeWithEncodedParameters,
  from: data.address,
  gasPrice: web3.utils.toHex(gasPrice)
});
```

위의 코드와 같이 인자를 주어야하는데 객체형태로 `data, from, gasPrice`를 넣어줘야 올바른 gas 사용량을 예상해준다.

이렇게 작성하니 `out of gas` 에러 없이 정상적으로 잘 작동하였다.

#### Error 03 ####

내가 클라이언트를 담당하지 않았지만 코드 리뷰 미팅할때 리액트에서 Environment Variable을 사용하는 부분에 문제가 발생했다고 클라이언트를 담당한 팀원분이 말씀해주셔서 같이 머리를 맞대고 해결해보았다.

일단 해당 부분을 맡은 팀원분이 환경 변수를 사용하기 위해서 백엔드에서 하듯이 **dotenv** 모듈을 설치해서 사용하려고 했는데 제대로 작동하지 않았다.

같이 검색을 하면서 왜그런지 알아보니 리액트는 기본적으로 create-react-app을 사용해서 리액트 프로젝트를 초기화하면 환경 변수를 사용할 수있도록 모듈이 이미 추가되어있었다.

그래서 추가적인 모듈의 설치를 하지않고 `.env` 파일을 생성하고 리액트에서 `process.env`를 이용해서 접근을 하면 되었다.

그래도 정상적으로 설정해둔 `.env` 파일안의 환경 변수들을 사용할 수 없었는데 리액트에서 환경 변수를 사용하기 위해서는 환경변수의 이름 앞에 prefix로 `REACT_APP_`이라고 붙어주어야지 제대로 사용할 수 있었다.

이때까지 개인적으로 포트폴리오를 만들면서 리액트 어플리케이션도 몇개 만들어봤는데 환경 변수를 사용하는 일은 없어서 전혀 몰랐던 사실이었다.

팀원들과 자기가 겪은 이슈를 코드 리뷰 미팅에서 같이 이야기를 나누면서 내가 직접적으로 클라이언트를 개발하지는 않았더라도 여러가지를 배울 수 있었다.

#### Error 04 ####

네번째 에러도 클라이언트 부분에서 발생했던 부분인데 API 요청을 하기 위해서 axios를 사용해서 데이터를 받아보는데 이러한 요청은 사이드 이펙트를 부르기 때문에 `useEffect()` 함수를 이용해서 핸들링하여야 한다.

클라이언트를 담당한 팀원분도 `useEffect()`를 사용해서 구현하려고 했으나 해당 함수를 사용하면 계속해서 `useEffect()`가 실행되는 문제가 발생되었다.

이 부분은 내가 예전에 useEffect함수와 관련해서 블로깅한 부분이 있어서 나의 [블로그 포스트](https://robin-the-dev.github.io/react/2022/01/22/react-useEffect.html)를 공유하면서 해결하였다.

아마도 useEffect함수를 사용할때 두번째 인자의 dependency부분을 주지 않아서 계속 re-rendering되면서 문제가 발생한듯 하였다.

클라이언트에서 해당 컴포넌트 페이지는 마운트 될때마다 API 요청을 해서 데이터를 받기만 하면되기 때문에 빈 배열로 두번째 인자를 채워주면서 해결하였다.

#### Error 05 ####

마지막으로 이 에러는 스마트 컨트랙트에서 발생했다.

우리는 두개의 스마트 컨트랙트가 필요했는데 ERC-20과 ERC-721이 그것이다.

유저 계정이 직접 트랜잭션을 보내는 식으로 개발을 하면 그냥 OpenZeppelin을 이용해서 가장 기본적인 ERC-20과 ERC-721을 구현하면 되지만

우리 프로덕트는 서버 계정이 대신해서 트랜잭션을 보내기때문에 각 스마트 컨트랙트에서 서버 계정이 사용할 수 있도록 함수를 추가 해주어야했다.

ERC-20의 스마트 컨트랙트에서는 항상하듯이 mintToken이라는 함수를 만들어 주었는데 기존의 mintToken 함수와 다르게 서버 계정에게 approve해서 서버 계정이 유저들의 토큰을 transfer 할 수 있도록 해주었다.

어려운 부분은 ERC-721의 스마트 컨트랙트였는데 우리가 구현한 ERC-20의 스마트 컨트랙트의 토큰으로 ERC-721의 스마트 컨트랙트의 NFT를 구매할수있게 했어야했다.

그렇게 할 수 있게 하기위해서 

```solidity
contract AbdoNFT is ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    IERC20 token;

    constructor() ERC721("AbdoNFT", "PNFT") {}

    function mintNFT(
        address recipient,
        string memory tokenURI,
        uint256 nftPrice
    ) public onlyOwner returns (uint256) {
        require(token.balanceOf(recipient) >= nftPrice);

        token.transferFrom(recipient, msg.sender, nftPrice);

        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(recipient, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }

    function setToken(address tokenAddress) public onlyOwner returns (bool) {
        require(tokenAddress != address(0x0));
        token = IERC20(tokenAddress);
        return true;
    }
}
```

이렇게 코드를 작성했다. 먼저 `setToken()` 함수는 우리가 배포한 ERC-20 스마트 컨트랙트의 토큰을 사용할 수 있게끔 OpenZeppelin의 ERC-20 인터페이스를 이용해서 `token = IERC20(tokenAddress);` 하여 사용할 토큰을 set 해주었다.

그다음은 `mintNFT()` 함수인데 이 부분도 크게 어려운건 없고 기존에 자주 사용하던 mintNFT 함수를 살짝 수정해주었다.

setToken() 함수에서 set 해준 token 변수를 이용해서 충분히 balance가 있는지 확인하고 충분하다면 해당 양만큼 서버계정으로 transferFrom 함수를 이용해서 옮겨준후에 nft를 민팅해주는 식이다.

문제는 잘 작동해야하는 코드가 자꾸 `Insufficient funds`라는 메세지를 뿜으면서 ERC-20에서의 transferFrom 함수에서의 require문에서 자꾸 걸려서 트랜잭션이 제대로 성공하지 않았다.

OpenZeppelin이 제공해주는 transferFrom을 살펴보며 무엇이 문제인지 훑어보았고 ERC-721에서 ERC-20의 함수를 호출할때 msg.sender가 ERC-721의 주소로 설정되어 발생되는 문제인것 같아서 transferFrom함수의 두번째 인자인 to를 서버계정의 주소로 바꿔주었는데도 계속해서 같은 메세지를 뿜었다.

분명히 제대로 한것같은데도 작동이 안되어서 또 팀원들과 함께 머리를 맞대며 고민해보았는데 내가 테스트를 해보기 위해서 to 부분을 하드코딩으로 서버 계정의 주소를 집어넣었는데

팀원 한분이 대소문자를 구별해서 생기는 이슈를 겪은적이 있어 대소문자 이슈일수도있으니 하드코딩하지말고 인자로 전해받은 서버 계정 주소를 넣어보자고 했다. (여기서는 to 매개변수가 서버계정의 주소를 받기때문에 to를 넣었다.)

그래서 코드를

```solidity
function transferFrom(
  address from,
  address to,
  uint256 amount
) public virtual override returns (bool) {
  _spendAllowance(from, to, amount);
  _transfer(from, to, amount);
  return true;
}
```

이렇게 작성하여 override 했더니 그제서야 제대로 트랜잭션이 성공했다... ㅋㅋㅋ

대소문자를 구별하는거는 web3.js 모듈을 이용해서 JavaScript 언어로 사용할때만 생기는 이슈인지 알았는데

solidity도 어이없게도 대소문자를 구별하는것이였다!!!

아무튼 이렇게 transferFrom 함수를 override 하는 식으로 해결하였다.

### Sprint 03 ###

Sprint 03는 디버깅과 리팩토링을 하기로 하였다.

하지만 사실 Sprint 03에서는 예정한대로 원활하게 흘러가지는 않았다.

스마트 컨트랙트를 담당했던 팀원 분께서 조금 느리게 진행이 되어서 해당부분을 같이 미팅때 해결해가면서 일정을 정확하게 맞추지 못하였다.

다행히 Sprint 02에서 시간이 허락할때 리팩토링을 진행하며 했기에 그리고 큰 버그가 발생하지는 않아서 스마트 컨트랙트게 늦게 완료되는대로 바로 기능을 구현해서

프로덕트를 완성하였다.

조금 역량이 부족한 팀원이 있으면 팀장으로서 잘 살펴가며 이끌어갔어야했는데 이 부분에서는 소통이 좀 부족하지 않았나싶다.

조금 더 팀원들을 살피며 프로젝트를 진행해야겠다고 느꼈다.

### 느낀점 ###

이번 프로젝트는 프로젝트 1과 다르게 다양한 이슈를 겪으며 기술적인 역량도 쌓을 수 있는 기회가 되었다.

위에서 얘기한대로 소통을 중요시하며 다음 프로젝트 3도 잘 진행 해볼 수 있도록 해야겠다.
