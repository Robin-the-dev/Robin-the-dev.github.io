---
layout: post
title: 웹 개발에서의 인증
subtitle: 다양한 인증 방법과 보안
categories: Authentication
tags: [Authentication, Authorisation, Cookie, Session, Token, JWT, OAuth]
---

Authentication (인증)
------------

회고에서도 적었다시피 이번 8주차에서 몸관리에 실패를 해서 이제서야 8주차에서 배운 것들에 대해 포스팅을 해본다.

8주차에서는 3일정도 인증에 대해서 학습을 하였는데 어디서 한번쯤 들어보기만 했지 처음으로 새로운 것에 대해서 배우게 되었다.

그만큼 시행착오도 크고 막히는 부분이 있었지만 결국 잘 해결해나가서 나의 것으로 만들었다는 그 쾌감이 나를 더 뿌듯하게 했다.

아무튼 그러면 사족은 집어 치우고 바로 본론에 대해서 얘기를 해보겠다.

일단 3일동안의 인증 학습에서 기술적으로는 `CooKie, Session, Token, JWT, OAuth`에 대해서 배웠다.

그전에 이론적인 부분인 Authentication과 Authorisation에 대해서도 간략하게 살펴보았다.

그러면 일단 이론적인 부분부터 포스팅을 해나가 보겠다.

### Authentication (인증)과 Authorisation (권한 부여) ###

**인증**에 대해서 배워보고자 한다면 항상 같이 친구처럼 다니는 녀석이 **권한 부여**이다. 영단어 생긴것도 비슷하고 그놈이 그놈같아서

쉽게 헷갈릴 수 있으니 여기서 저 둘에 대해서 간단하게 정리를 해보고 가려고 한다.

일단 인증과 권한 부여라고 하면 말이 너무 어려운 것 같다. 나는 개발을 지망하는 개발자 지망생이기도 하지만 매일 인터넷을 사용하고 있는

유저 이기도 하기에 편하게 유저입장에서 저 인증과 권한 부여를 정리 해보겠다.

#### 인증 ####

인증은 `나라는 사람(신원)을 확실히 확인 및 검증` 하는 것이다.

이렇게 말하면 헷갈리니 예를 몇가지 들어보면 아이폰을 사용하는 사람들은 이제 대부분 안면인식 잠금해제를 사용할 것이다.

사용자가 초기에 설정해놓은 인증의 키로 자신의 얼굴을 등록 했을 것이고 그 설정 이후에는 이제 자신의 얼굴을 이용해서 잠금해제를 할 수 있다.

그렇게 잠금해제를 하면 이제 사용자는 휴대폰 안에 있는 사진, 영상 등 다양한 데이터에 접근이 가능하고 이를 자유롭게 이용 할 수 있다.

또 다른 예로는 로그인이 있다. 네이버에서는 로그인을 하지않아도 이용 할 수 있는 서비스가 많이 있지만 사용자가 로그인을 하고 나면 

로그인된 사용자의 정보들을 종합해 더 알맞은 정보를 제공해주거나 로그인을 해야만 사용할 수 있는 서비스에 접근이 가능해진다.

이 예들 중에서 인증은 각각 **안면인식 잠금해제**와 **로그인**이다. 이러한 인증단계를 각자의 키 (이 예들에서는 얼굴과 비밀번호가 되겠다.)를 이용해서 나라는 신원을 확실히 확인시켜주면

이제 각종 데이터나 서비스를 이용 할 수 있게 되는것이다.

#### 권한 부여 ####

이제 항상 인증과 같이 딸려오는 권한 부여에 대해서 얘기해보겠다.

이것도 예를 들면 이해하기 더 편할듯하니 위에서 들었던 네이버 로그인 예에서 덧붙여보겠다.

그럼 위의 인증에서 얘기했듯이 네이버에 로그인을 함으로서 나의 신원을 인증하여 데이터에 대한 접근이나 서비스를 이용 할 수 있게 되었다.

그렇게 로그인을 한 상태 (인증이 되어진 상태)에서 A라는 사람의 블로그를 탐방을 갔다고 하자!

거기서 내가 할 수 있는 것은 블로그의 포스트를 보는것이나 댓글을 다는것 밖에 할 수 없다.

이 부분을 한번 정리해보면 A라는 사람의 블로그는 내 블로그가 아니기에 포스트의 수정이나 블로그 주인이 할 수 있는 기능들을 사용 할 수 없다.

이것을 다시 정리해보면 나는 블로그를 `방문한 방문자로서 포스트를 보거나 댓글을 달거나 하는 권한`만 가지고 있다.

반면에 블로그의 주인인 A가 로그인을 해서 자신의 블로그에 들어오면 방문자가 가지는 권한보다 더 강력한 권한을 가질 것이다.

#### 정리를 해보면... ####

그래서 인증과 권한부여에 대해서 정리를 해보자면 인증은 개개인의 신원을 확인하는 것이고 권한부여는 그 인증이 일어난 이후 개개인에게

알맞은 권한을 부여해줌으로서 보안적으로 안정성을 꾀하는 것이라고 말할수있겠다.

군필자라면 더 알아듣기 쉬운 예를 한번 해보자면 나의 군번과 관등성명을 대서 인증을 한 후 내가 가지고 있는 권한에 알맞게 기밀 정보에 접근이 가능한 것이다. (1급 비밀, 2급 비밀, 대외비 등 등으로 나눠져 있을것이다. 당연히 더 높은 계급을 가진 군인은 더 높은 권한을 가지고 있어서 모든 기밀에 접근이 가능할 것 이다.)

그리고 인증과 권한 부여에 더 자세히 정리를 해놓은 [블로그](https://baek.dev/post/24/)가 있어서 같이 링크를 걸어놓아 본다.

### Cookie ###

위에서 이론적인 부분에 대한 정리를 마쳤으니 이제부터 인증을 위한 기술적인 부분에 대해서 정리를 해보겠다.

그 처음은 당연히 쿠키이다!

쿠키라는 것은 사실 개발을 하지 않는 일반 사용자들도 충분히 많이 들어봤을 것이다. 특정 웹사이트에 들어가면 더 나은 유저경험을 위해

쿠키에 사용자 정보를 저장해둘건데 동의를 해달라하면서 팝업이 뜨는것을 많이 봤을 것이다.

동의를 해주면 다음에 그 사이트를 방문했을때도 나라는 사용자를 사이트가 알아보고 거기에 맞는 정보들을 제공해준다.

이처럼 쿠키라는 것은 `브라우저상에 서버의 요청에 따라 몇몇 데이터를 저장해놓았다가 그 데이터를 이용`하게 해주는 것이라고 보면 되겠다.

이러한 쿠키가 왜 필요한가에 대한 이유에 대해서는 먼저 클라이언트와 서버가 요청과 응답을 주고 받을때 사용하는 http 프로토콜에 대해서 

먼저 간단하게 집고 넘어 가겠다.

#### HTTP ####

쿠키 얘기하다가 HTTP 얘기가 HTTP가 가지는 두가지 특성 때문이다.

그 특성은

- Stateless (무상태성)
- Connectionless (비연결성)

이다.

무상태성이라는 것은 `서버는 클라이언트가 어떤 상태인지 전혀 모르는 것`이다.

HTTP는 알다시피 요청과 응답으로 이루어져있는데 서버가 응답을 보내고나면 그 전의 요청이 뭐였는지 다 잊어버린다는 말이다.

비연결성은 바로 윗줄에서 언급했는데 요청과 응답이 이뤄지면 바로 연결을 끊어 서버 트래픽관리에 용이하게 해주는 특성이다.

지금은 쿠키에 대해서 얘기하고 있기때문에 무상태성에만 집중하면 되는데 설명한 것 처럼 응답이 끝나면 서버가 클라이언트의 상태를

바꿔줄수도 있는 데이터를 응답으로 보내주었다 할지라도 클라이언트의 상태에 대해서 전혀 알지 못한다.

그렇기 때문에 쿠키라는 것이 나온것이고 응답에 쿠키헤더를 작성해서 어떤 데이터를 클라이언트(브라우저)의 쿠키에 저장할지를 명시 해주면

그 데이터가 쿠키에 저장이 되어있고 저장된 쿠키는 요청을 보낼때마다 함께 보내지기 때문에 서버는 클라이언트의 상태를 알 수 있게된다.

### Session ###

위에서 쿠키에대해 설명을 했고 이제 세션에 대해서 얘기를 해볼건데 위의 쿠키에서 그대로 이어진다고 생각하면 이해하기 더 편할듯 하다.

쿠키는 기본적으로 클라이언트 사이드에 저장이 되어있다. 문제는 클라이언트에 저장이 되어있기때문에 보안적으로 아주 취약하다.

보통 로그인을 했을때 로그인을 했다는 상태를 저장하려고 쿠키를 쓰는것인데 그 쿠키에 로그인 정보같은 민감한 정보가 담겨 있으면

이는 해킹의 위험이 있기 때문에 보안적으로 좋지않다.

그래서 나온것이 세션이라고 생각하면 되겠다.

세션은 쿠키와 다르게 서버 사이드에서 데이터가 저장이 된다. 그렇기 때문에 보안적으로도 안전하다.

로그인으로 예를 들어보면 유저 A가 로그인을 했다고 가정하자! 그러면 서버는 인증단계를 거쳐서 A라는 유저가 정확한 비밀번호를 입력했는지

확인 한 후 서버쪽에 세션이라는 공간을 만들고 거기에 로그인 정보와 민감한 정보들을 담아둔다.

하지만 서버쪽에서만 세션을 만들고 데이터를 저장해놓으면 클라이언트쪽에서 로그인을 했는지 안한지에 대해서는 무상태성으로 인해

서버는 전혀 알수없다.

그렇기 때문에 세션이라는 공간을 만들면서 고유한 세션아이디를 부여하고 그 세션아이디를 쿠키를 통해 클라이언트로 넘겨줘서

요청이 들어왔을때 쿠키안의 세션아이디를 서버쪽에서 검색해서 일치하는 세션이 있으면 로그인이 되어있다는 것으로 간주하는 것이다.

이렇게 세션을 사용하면 모든 것들이 해결 된 것 처럼 보이지만 몇가지 단점은 존재한다.

첫번째로 결국 세션아이디를 쿠키를 통해 넘겨주었기 때문에 해당 세션아이디가 탈취될 위험은 존재한다. (물론 탈취한 세션아이디로 요청을 보낼경우 도메인이 달라 거절될거 같기는 하지만 말이다...)

두번째로 세션이라는 공간을 서버쪽에서 다른 유저들이 로그인이 될때마다 만들어내야하기 때문에 대규모 서비스에서 세션을 사용하려면 그만큼 큰 서버가 필요하고 이는 금전적인 문제로 이어진다.

단점은 이정도가 되겠다. 다음으로 토큰에 대해서 알아보자!

### Token과 JWT ###

이 토큰도 위의 세션이랑 이어지는 부분이라고 보면 되겠다. 결국 토큰이라는 것도 세션의 단점들을 보완하기 위해 만들어진 녀석이라고 생각하면 좋겠다.

토큰과 JWT 그 자체에 대해서 설명을 해보려고 했는데 적어야 될 내용이 너무 많아서... ㅋㅋㅋ 일단 이 부분은 잘 정리되어 있는 [블로그](https://velopert.com/2389)로 대체하겠다.

나중에 시간이 된다면 나의 말로 다시 정리를 해보겠다.

그럼 토큰을 이용해서 어떻게 인증을 할 수 있고 세션의 단점을 어떻게 해결 할 수 있는지에 대해서만 얘기 해보겠다.

일단 위의 세션의 단점 중 하나가 서버가 힘들어한다는 것이다. 왜냐면 새로운 유저가 로그인을 할때마다 새로운 세션을 만들어야하기 때문이다.

그럼 이러한 짐을 클라이언트가 안전하게 가지고 있게 할 순 없을까 라는 생각에서 토큰이라는 것이 나온것이다.

일반적으로 쿠키를 이용해서 데이터를 저장해놓으면 암호화가 하나도 되어있지않기때문에 탈취 됐을때 위험이 너무 크다.

그래서 토큰이라는 것은 유저가 로그인을 했을때 서버에서 토큰을 생성하는데 해당 로그인 정보를 토큰안에 집어넣고 시크릿 키를 이용해서 암호화한 문자열이다. (더 자세한것은 위의 블로그 링크를 확인하자!)

결과적으로 토큰은 암호화가 되어있기 때문에 민감 데이터를 바로 쿠키에 넣어서 보내는 것 보다 훨씬 안전하기 때문에 이제 응답을 보낼때 쿠키 혹은 Authorization 이라는 응답 헤더에 넣어 보낼 수 있다.

(즉 안전해졌기 때문에 클라이언트 사이드로 응답에 넣어 보낼 수 있다는 말이다.)

위에서 세션의 단점을 어떻게 해결하는가에 대해서만 말을 했었는데 사실 토큰을 사용함으로서 세션의 문제점과 쿠키의 문제점을 동시에 해결 하게 된것이다.

### 마치며 ###

이렇게 인증에 대해서 블로깅을 해봤는데 세션과 쿠키까지는 스무스했는데 토큰에서 생각보다 적어야 할 내용이 너무 방대해서 그냥 전체적인

개요에 대해서만 적은 것 같다. 나중에 시간이 된다면 토큰 그 자체에 대해서 포스팅을 하는게 좋다고 생각한다.

그리고 직접 쿠키, 세션, 토큰을 구현해보면서 생긴 문제에 대해서 포스트 중간에 적을까 했는데 너무 난잡하게 될거같아 여기에 간단하게 적어본다.

일단 클라이언트와 서버가 쿠키를 주고 받으려면 꼭 설정해줘야하는 부분이 있다.

- 프론트 쪽에서는 요청을 보낼때 withCredentials 옵션을 true로 주어야하고 (default는 false)
- 백엔드 쪽에서는 응답을 보낼때 Access-Allow-Control-Credentials 헤더를 true로 주어야한다.

알아두어야 하는 것이 withCredentials는 옵션이고 Access-Allow-Control-Credentials는 헤더이다.

백엔드에서 cors 모듈을 사용했다면 cors 모듈의 옵션 값을 설정 할 때 credentials: true를 주면 된다.

```nodejs
// Front-end
axios.post('http://localhost:4000/login', {userId, password}, {headers: {}, withCredentials: true});

// Back-end
app.use(cors({origin: 'http://localhost:3000', credentials: true}));
```

이처럼 해주면 된다. 자세하게 살펴보지는 못했는데 withCredentials라는 옵션은 xmlHttpRequest객체와 관련이 있는듯 하다.

관련 사이트를 링크로 걸어놓겠다.

[블로그](https://kosaf04pyh.tistory.com/152), [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)

P.S: 아 그리고 쿠키를 주고 받기 위해서 withCredentials 옵션을 열어놨을때는 cors의 Access-Control-Allow-Origin헤더에게 와일드 카드(\*)를 줄 수 없다!!! 위의 블로그의 하단에 관련 설명이 나와있으니 참고하자!!!

P.S: 아 또 OAuth 부분을 깜빡했는데 이 부분은 실제로 깃허브 OAuth 이용하는 것도 포스팅 해보려고 하니까 길어질것 같아서 그냥 다른 포스트에 적어보겠다!
